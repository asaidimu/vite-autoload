{
  "system": {
    "name": "@asaidimu/vite-autoload",
    "language": "TypeScript",
    "description": "An enhanced Vite plugin for automatic route and module loading, including sitemap, PWA manifest, and type definition generation with advanced metadata extraction.",
    "keyFeatures": [
      "Automatic Route & Module Generation via filesystem",
      "Virtual Module exposure for type-safe imports",
      "Hot Module Replacement (HMR) for tracked file changes",
      "Sitemap Generation for SEO",
      "PWA Manifest Generation for Web Apps",
      "TypeScript Type Definition Generation",
      "Metadata Extraction using TypeScript AST and Zod schemas",
      "Highly Configurable options for transformation and output",
      "Performance optimization through chunking and watcher tuning"
    ]
  },
  "dependencies": {
    "external": [
      {
        "name": "vite",
        "purpose": "Core build tool and development server platform that the plugin extends.",
        "interfaces": [
          {
            "name": "Plugin",
            "description": "Vite's plugin interface, which the `createAutoloadPlugin` function adheres to, allowing it to integrate into Vite's build lifecycle.",
            "methods": [
              {
                "name": "configResolved",
                "signature": "(config: ResolvedConfig) => void",
                "parameters": "config: The resolved Vite configuration object.",
                "returnValue": "void"
              },
              {
                "name": "configureServer",
                "signature": "(server: ViteDevServer) => Promise<void> | void",
                "parameters": "server: The Vite development server instance.",
                "returnValue": "void"
              },
              {
                "name": "buildStart",
                "signature": "() => Promise<void> | void",
                "parameters": "None.",
                "returnValue": "void"
              },
              {
                "name": "resolveId",
                "signature": "(id: string, importer?: string, options?: { isEntry: boolean, custom?: CustomPluginOptions }) => string | null | Promise<string | null>",
                "parameters": "id: The module request id. importer: The module that imports this id. options: Resolution options.",
                "returnValue": "Resolved module ID or null."
              },
              {
                "name": "load",
                "signature": "(id: string) => string | null | Promise<string | null>",
                "parameters": "id: The resolved module ID.",
                "returnValue": "The module's source code as a string or null."
              },
              {
                "name": "transformIndexHtml",
                "signature": "(html: string) => string | HtmlTagDescriptor[] | Promise<string | HtmlTagDescriptor[]>",
                "parameters": "html: The original HTML content.",
                "returnValue": "Transformed HTML string or an array of tag descriptors."
              },
              {
                "name": "transform",
                "signature": "(code: string, id: string, options?: { ssr?: boolean }) => string | { code: string; map?: SourceMapInput } | null | Promise<string | { code: string; map?: SourceMapInput } | null>",
                "parameters": "code: The module's source code. id: The module's resolved ID. options: Transform options.",
                "returnValue": "Transformed code, optionally with a source map, or null."
              },
              {
                "name": "handleHotUpdate",
                "signature": "({ file, server, modules, timestamp }: HmrContext) => ModuleNode[] | void | Promise<ModuleNode[] | void>",
                "parameters": "HmrContext: Object containing file path, Vite dev server, affected modules, and timestamp.",
                "returnValue": "Array of affected module nodes or void."
              },
              {
                "name": "closeBundle",
                "signature": "() => Promise<void> | void",
                "parameters": "None.",
                "returnValue": "void"
              }
            ]
          }
        ],
        "installation": "`npm install vite` or `bun add vite`",
        "version": "^6.1.0"
      },
      {
        "name": "zod",
        "purpose": "Schema declaration and validation library, used for validating extracted metadata.",
        "interfaces": [
          {
            "name": "ZodType",
            "description": "The base interface for all Zod schemas, defining methods like `parse` and `safeParse` for data validation.",
            "methods": []
          }
        ],
        "installation": "`npm install zod` or `bun add zod`",
        "version": "^3.24.1"
      },
      {
        "name": "chokidar",
        "purpose": "Fast and reliable file system watcher, used for detecting changes in source directories to trigger HMR and regeneration.",
        "interfaces": [
          {
            "name": "FSWatcher",
            "description": "Chokidar's file system watcher instance, providing methods for watching paths and event listeners for file system events.",
            "methods": [
              {
                "name": "watch",
                "signature": "(paths: string | string[], options?: WatchOptions) => FSWatcher",
                "parameters": "paths: A single path or array of paths to watch. options: Chokidar watch options.",
                "returnValue": "The FSWatcher instance itself."
              },
              {
                "name": "on",
                "signature": "(event: 'add' | 'change' | 'unlink' | 'error', listener: (...args: any[]) => void) => FSWatcher",
                "parameters": "event: The event name ('add', 'change', 'unlink', 'error'). listener: The callback function for the event.",
                "returnValue": "The FSWatcher instance itself."
              },
              {
                "name": "close",
                "signature": "() => Promise<void>",
                "parameters": "None.",
                "returnValue": "A Promise that resolves when the watcher is closed."
              }
            ]
          }
        ],
        "installation": "`npm install chokidar` or `bun add chokidar`",
        "version": "^3.5.3"
      },
      {
        "name": "es-module-lexer",
        "purpose": "A fast ECMAScript module lexer used for static analysis of import/export statements to determine module dependencies for HMR.",
        "interfaces": [
          {
            "name": "Lexer",
            "description": "Provides functions to parse ES module syntax.",
            "methods": [
              {
                "name": "init",
                "signature": "() => Promise<void>",
                "parameters": "None.",
                "returnValue": "A Promise that resolves when the lexer is initialized."
              },
              {
                "name": "parse",
                "signature": "(source: string, filename?: string) => [Import[], Export[], string[]]",
                "parameters": "source: The JavaScript/TypeScript source code. filename: Optional filename for error reporting.",
                "returnValue": "A tuple containing arrays of imports, exports, and re-exports."
              }
            ]
          }
        ],
        "installation": "`npm install es-module-lexer` or `bun add es-module-lexer`",
        "version": "^1.6.0"
      },
      {
        "name": "@babel/parser",
        "purpose": "A JavaScript parser used for converting source code into an Abstract Syntax Tree (AST), enabling deeper static analysis for metadata extraction.",
        "interfaces": [
          {
            "name": "parse",
            "description": "Parses JavaScript/TypeScript code into an AST.",
            "methods": [
              {
                "name": "parse",
                "signature": "(code: string, options?: ParserOptions) => ParseResult<File>",
                "parameters": "code: The source code string. options: Parsing options (e.g., sourceType, plugins).",
                "returnValue": "An AST representation of the code."
              }
            ]
          }
        ],
        "installation": "`npm install @babel/parser` or `bun add @babel/parser`",
        "version": "^7.26.5"
      },
      {
        "name": "@babel/traverse",
        "purpose": "Enables traversing and manipulating ASTs generated by @babel/parser, essential for precisely locating and extracting metadata nodes.",
        "interfaces": [
          {
            "name": "traverse",
            "description": "Walks the AST, calling visitor functions for specific node types.",
            "methods": [
              {
                "name": "traverse",
                "signature": "(node: Node, opts: TraverseOptions, scope?: Scope, state?: any, parentPath?: NodePath)",
                "parameters": "node: The AST node to start traversal from. opts: Visitor object with functions for node types. scope: The current scope. state: User-defined state. parentPath: The parent node path.",
                "returnValue": "void"
              }
            ]
          }
        ],
        "installation": "`npm install @babel/traverse` or `bun add @babel/traverse`",
        "version": "^7.26.5"
      },
      {
        "name": "playwright",
        "purpose": "A Node.js library for automating Chromium, Firefox and WebKit with a single API. While listed as a dev dependency, its direct purpose in this plugin's current functionality (based on the provided code) is not immediately evident from core logic but suggests potential for browser-based asset analysis or testing utilities in the build process.",
        "interfaces": [],
        "installation": "`npm install playwright` or `bun add playwright`",
        "version": "^1.49.1"
      }
    ],
    "peer": [
      {
        "name": "typescript",
        "reason": "Required for TypeScript compilation and static AST analysis in the `metadata` extraction utility.",
        "version": "~5.7.2"
      }
    ]
  },
  "integration": {
    "environmentRequirements": "The plugin is designed to run within a Node.js environment (LTS version, v18 or higher) as part of a Vite project (v6.0.0 or higher). It requires a modern JavaScript runtime with ES module support. No specific compiler settings are strictly enforced beyond what Vite typically requires, but the use of TypeScript is integral for the `extract` function's static analysis capabilities.",
    "initializationPatterns": [
      {
        "description": "Integrating the `@asaidimu/vite-autoload` plugin into your Vite project's `vite.config.ts`.",
        "codeExample": "import { defineConfig } from \"vite\";\nimport { createAutoloadPlugin, extract } from \"@asaidimu/vite-autoload\";\nimport createAutoloadConfig from \"./autoload.config\"; // Your custom autoload config file\n\nexport default defineConfig({\n  plugins: [\n    createAutoloadPlugin(createAutoloadConfig({ extract }))\n  ],\n});"
      },
      {
        "description": "Defining the `PluginOptions` in a dedicated configuration file (`autoload.config.ts`). This is where all the logic for file matching, transformation, and output generation is set up.",
        "codeExample": "import { z } from \"zod\";\nimport type { ExtractFunction, PluginOptions } from \"@asaidimu/vite-autoload\";\n\ninterface ConfigOptions {\n  readonly extract: ExtractFunction;\n}\n\nexport default function createAutoloadConfig({ extract }: ConfigOptions): PluginOptions {\n  return {\n    rootDir: process.cwd(),\n    export: {\n      types: \"src/app/config/autogen.d.ts\",\n      routeLimit: 1000,\n    },\n    sitemap: {\n      output: \"sitemap.xml\",\n      baseUrl: \"https://example.com\",\n      exclude: [\"/admin/*\", \"/private/*\"],\n    },\n    manifest: {\n      name: \"My PWA App\",\n      shortName: \"PWA App\",\n      description: \"A Progressive Web Application\",\n      theme_color: \"#4a90e2\",\n      background_color: \"#ffffff\",\n      display: \"standalone\",\n      start_url: \"/\",\n      icons: [\n        { src: \"/icons/icon-192x192.png\", sizes: \"192x192\", type: \"image/png\" },\n        { src: \"/icons/icon-512x512.png\", sizes: \"512x512\", type: \"image/png\" },\n      ],\n      output: \"manifest.webmanifest\",\n    },\n    routes: {\n      views: {\n        input: {\n          directory: \"ui\",\n          match: [\"*.ts\"],\n          prefix: \"/views/\",\n        },\n        output: {\n          name: \"views\",\n          template: \"export const views = {{ data }};\",\n          types: { name: \"ViewKeys\", key: \"route\" }\n        },\n        transform: (view) => {\n          const route = view.path\n            .replace(/.*ui/, \"\")\n            .replace(/\\\\/g, \"/\")\n            .replace(/\\.tsx?$/, \"\")\n            .replace(/index.?$/, \"\");\n\n          return {\n            route: route.length === 1 ? route : route.replace(new RegExp(\"/$\"), \"\"),\n            path: view.uri,\n            module: route.split(\"/\")[0],\n            metadata: extract({\n              filePath: view.file,\n              schema: z.object({ \n                title: z.string(), \n                description: z.string().optional() \n              }),\n              name: \"metadata\",\n            }),\n          };\n        },\n      },\n      pages: {\n        input: {\n          directory: \"src/interface/pages\",\n          match: [\"*.tsx\", \"*/index.tsx\"],\n        },\n        output: {\n          name: \"pages\",\n          template: \"export const pages = {{ data }};\",\n        },\n        transform: (page) => {\n          const route = page.path\n            .replace(/.*src\\/interface\\/pages/, \"\")\n            .replace(/\\\\/g, \"/\")\n            .replace(/\\.tsx?$/, \"\")\n            .replace(/index.?$/, \"\");\n          return {\n            route: route || \"/\",\n            path: page.uri,\n            metadata: extract({\n              filePath: page.file,\n              schema: z.object({ title: z.string(), authRequired: z.boolean().optional() }),\n              name: \"metadata\",\n            }),\n          };\n        },\n      },\n    },\n    modules: {\n      components: {\n        input: {\n          directory: \"src/components\",\n          match: [\"*.tsx\", \"*/index.tsx\"],\n          ignore: [\"**/__tests__/**\"],\n          prefix: \"/components/\"\n        },\n        output: {\n          name: \"components\",\n          template: \"export const components = {{ data }};\\nexport default components;\",\n          types: { name: \"ComponentKeys\", key: \"name\" }\n        },\n        transform: (item) => ({\n          name: item.path.split('/').pop()?.replace(/\\.tsx?$/, ''),\n          route: item.path,\n          path: item.uri\n        }),\n        aggregate: (items) => items.reduce((acc, item) => ({ ...acc, [item.name!]: item.path }), {})\n      },\n      hooks: {\n        input: { directory: \"src/hooks\", match: [\"*.ts\"] },\n        output: { name: \"hooks\" },\n        transform: (item) => ({\n          name: item.path.split('/').pop()?.replace(/\\.ts$/, ''),\n          path: item.uri\n        }),\n      }\n    },\n    logLevel: \"info\",\n    chunkSize: 100,\n    watch: {\n      debounceTime: 1000,\n      stabilityThreshold: 300\n    }\n  };\n}"
      }
    ],
    "commonPitfalls": [
      {
        "issue": "Incorrect `rootDir` or relative paths.",
        "solution": "Ensure `rootDir` is correctly set if your `autoload.config.ts` is not in the project root. All relative paths for `export.types` should be relative to `rootDir`."
      },
      {
        "issue": "File watcher not triggering HMR.",
        "solution": "Ensure your application code actually imports the virtual modules (e.g., `virtual:routes`). The plugin needs this dependency chain to correctly invalidate modules. Also, verify `watch.debounceTime` and `watch.stabilityThreshold` settings are appropriate for your environment."
      },
      {
        "issue": "Metadata extraction failing or returning `null`.",
        "solution": "Double-check that the `name` provided to `extract` matches the exported constant/default in your source file. Ensure the `zod` schema accurately reflects the structure of your metadata, including optional properties (`.optional()`) and default values (`.default()`)."
      }
    ],
    "lifecycleDependencies": "The plugin's lifecycle is tightly integrated with Vite's build and development server hooks:\n\n*   **`configResolved`**: Used to capture Vite's final configuration.\n*   **`configureServer` (Dev)**: Initializes internal generators, populates caches, and starts the file watcher. This must complete before HMR can function.\n*   **`buildStart` (Build)**: Initializes generators for production, resolves module paths, and emits them as Vite chunks.\n*   **`resolveId` & `load`**: Handle requests for virtual modules (`virtual:...`). These need to be active for your application to import the generated data.\n*   **`transform`**: Analyzes importer modules to establish dependencies on virtual modules, crucial for fine-grained HMR updates.\n*   **`handleHotUpdate`**: Responds to file changes by invalidating relevant modules and triggering HMR updates.\n*   **`closeBundle` (Build)**: Generates `sitemap.xml`, `manifest.webmanifest`, and TypeScript types after the main build process is complete."
  },
  "types": {
    "LogLevel": {
      "id": "type:LogLevel",
      "definition": "type LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";",
      "purpose": "Defines the verbosity level for the plugin's internal logger.",
      "related": {
        "methods": ["method:createLogger"],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {}
      }
    },
    "Environment": {
      "id": "type:Environment",
      "definition": "type Environment = \"build\" | \"dev\";",
      "purpose": "Represents the build environment (development or production).",
      "related": {
        "methods": [],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {}
      }
    },
    "FileMatchConfig": {
      "id": "type:FileMatchConfig",
      "definition": "interface FileMatchConfig {\n  readonly directory: string;\n  readonly match: Array<string> | string;\n  readonly ignore?: Array<string> | string;\n  readonly prefix?: string;\n  readonly data?: Record<string, unknown>;\n}",
      "purpose": "Configuration for specifying which files to discover and include in a module group.",
      "related": {
        "methods": ["method:resolve"],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "directory": "string: The base directory to scan.",
          "match": "string | string[]: Glob patterns to match files.",
          "ignore": "string | string[] (optional): Glob patterns to exclude files.",
          "prefix": "string (optional): A string to prefix the `uri` of resolved files.",
          "data": "Record<string, unknown> (optional): Additional static data to inject into each transformed item."
        }
      }
    },
    "TransformContext": {
      "id": "type:TransformContext",
      "definition": "interface TransformContext<T> {\n  readonly views: ReadonlyArray<T>;\n  readonly environment?: Environment;\n  readonly emitFile?: (fileName: string, source: string) => void;\n}",
      "interfacecontract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "views": "ReadonlyArray<T>: An array of `ResolvedRouteModule` from views processing (for cross-module data access).",
          "environment": "Environment (optional): 'build' or 'dev'.",
          "emitFile": "(fileName: string, source: string) => void (optional): Vite's `emitFile` function for emitting assets during build."
        }
      }
    },
    "ExtractOptions": {
      "id": "type:ExtractOptions",
      "definition": "interface ExtractOptions {\n  readonly filePath: string;\n  readonly schema: z.ZodType;\n  readonly name: string;\n}",
      "purpose": "Parameters for the `extract` function to specify file, validation schema, and target export name.",
      "related": {
        "methods": ["method:extract", "method:createMetadataExtractor"],
        "patterns": ["pattern:MetadataExtraction"]
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "filePath": "string: The absolute path to the file.",
          "schema": "z.ZodType: A Zod schema for validation.",
          "name": "string: The name of the exported constant or 'default' for default exports."
        }
      }
    },
    "ExtractFunction": {
      "id": "type:ExtractFunction",
      "definition": "type ExtractFunction = (options: ExtractOptions) => Record<string, unknown>;",
      "purpose": "Type definition for the `extract` function used in `PluginOptions` to provide metadata extraction logic.",
      "related": {
        "methods": ["method:extract"],
        "patterns": ["pattern:MetadataExtraction"]
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {}
      }
    },
    "TransformConfig": {
      "id": "type:TransformConfig",
      "definition": "interface TransformConfig<T, R, A> {\n  readonly input: FileMatchConfig;\n  readonly output?: {\n    readonly name: string;\n    readonly template: string;\n    readonly types?: {\n      readonly name: string;\n      readonly key: string;\n    };\n  };\n  readonly transform?: (\n    item: ResolvedFile,\n    context: TransformContext<T> | Record<string, Array<{ module: string }>>,\n  ) => R;\n  readonly aggregate?: (items: R[]) => A;\n}",
      "purpose": "Configuration for transforming discovered files into structured data for virtual modules.",
      "related": {
        "methods": [],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "input": "type:FileMatchConfig: Defines file matching rules.",
          "output": "object (optional): Controls output name, template, and type generation.",
          "output.name": "string: Name of the exported variable in the virtual module.",
          "output.template": "string: Template string for virtual module code (`{{ data }}` placeholder).",
          "output.types": "object (optional): Configures TypeScript type generation.",
          "output.types.name": "string: Name of the generated TypeScript type.",
          "output.types.key": "string: Property key from transformed item to use for union type.",
          "transform": "(item: type:ResolvedFile, context: type:TransformContext<T> | Record<string, Array<{ module: string }>>) => R (optional): Function to transform each matched file into a custom data structure.",
          "aggregate": "(items: R[]) => A (optional): Function to combine all transformed items into a single aggregated structure."
        }
      }
    },
    "RouteData": {
      "id": "type:RouteData",
      "definition": "interface RouteData<T = any> {\n  readonly route: string;\n  readonly path: string;\n  readonly module?: string;\n  readonly metadata?: T;\n}",
      "purpose": "Represents a single transformed route or module entry, typically containing its route identifier, import path, and optional metadata.",
      "related": {
        "methods": [],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "route": "string: The unique identifier or URL path for the route/module.",
          "path": "string: The URI to load the module dynamically.",
          "module": "string (optional): A logical module name or group.",
          "metadata": "T (optional): Arbitrary metadata associated with the route/module."
        }
      }
    },
    "ResolvedRouteModule": {
      "id": "type:ResolvedRouteModule",
      "definition": "interface ResolvedRouteModule {\n  readonly path: string;\n  readonly uri: string;\n  readonly file: string;\n}",
      "purpose": "Internal representation of a resolved file, including its relative path, import URI, and absolute file system path.",
      "related": {
        "methods": ["method:resolve"],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "path": "string: The relative path of the file from its configured `directory`.",
          "uri": "string: The absolute URI to be used for dynamic imports (includes prefix if configured).",
          "file": "string: The absolute file system path to the source file."
        }
      }
    },
    "GeneratorDefinition": {
      "id": "type:GeneratorDefinition",
      "definition": "interface GeneratorDefinition {\n  readonly name: string;\n  readonly virtualId?: string;\n  readonly dataExtractor: (data: any, production: boolean) => Record<string, any[]>;\n  readonly codeGenerator: (data: Record<string, any[]>, production: boolean) => string;\n  readonly moduleResolver: (data: Record<string, any[]>, production: boolean) => ResolvedFile[];\n  readonly typesExtractor?: (data: Record<string, any[]>) => Record<string, string[]>;\n  readonly sitemapExtractor?: (data: Record<string, any[]>) => Array<{\n    route: string;\n    metadata?: any;\n  }>;\n}",
      "purpose": "Defines a pluggable generator for virtual modules, allowing custom logic for data processing, code generation, and type/sitemap extraction.",
      "related": {
        "methods": [
          "method:createDefaultModuleGenerator",
          "method:defaultRoutesGenerator",
          "method:createCustomGenerator"
        ],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [
          {
            "name": "name",
            "signature": "string",
            "parameters": "None.",
            "returnValue": "string: A unique identifier for the generator."
          },
          {
            "name": "dataExtractor",
            "signature": "(data: any, production: boolean) => Record<string, any[]>",
            "parameters": "data: Raw data from `createModuleGenerator`. production: Boolean indicating production build.",
            "returnValue": "Record<string, any[]>: Processed data for further generation steps."
          },
          {
            "name": "codeGenerator",
            "signature": "(data: Record<string, any[]>, production: boolean) => string",
            "parameters": "data: Extracted data. production: Boolean indicating production build.",
            "returnValue": "string: The JavaScript code content for the virtual module."
          },
          {
            "name": "moduleResolver",
            "signature": "(data: Record<string, any[]>, production: boolean) => ResolvedFile[]",
            "parameters": "data: Extracted data. production: Boolean indicating production build.",
            "returnValue": "type:ResolvedFile[]: Array of resolved file objects that are actual modules."
          }
        ],
        "optionalMethods": [
          {
            "name": "virtualId",
            "signature": "string",
            "defaultBehavior": "Defaults to `virtual:${name}`.",
            "parameters": "None.",
            "returnValue": "string: The virtual module ID (e.g., `virtual:my-module`)."
          },
          {
            "name": "typesExtractor",
            "signature": "(data: Record<string, any[]>) => Record<string, string[]>",
            "defaultBehavior": "No type extraction.",
            "parameters": "data: Extracted data.",
            "returnValue": "Record<string, string[]>: Map of type names to string arrays of values."
          },
          {
            "name": "sitemapExtractor",
            "signature": "(data: Record<string, any[]>) => Array<{ route: string; metadata?: any }>",
            "defaultBehavior": "No sitemap entries extracted.",
            "parameters": "data: Extracted data.",
            "returnValue": "Array<{ route: string; metadata?: any }>: Array of sitemap entries."
          }
        ],
        "parameterObjectStructures": {}
      }
    },
    "RoutesConfig": {
      "id": "type:RoutesConfig",
      "definition": "interface RoutesConfig {\n  readonly views: TransformConfig<ResolvedRouteModule, RouteData, any>;\n  readonly pages: TransformConfig<ResolvedRouteModule, RouteData, any>;\n  readonly generator?: GeneratorDefinition;\n}",
      "purpose": "Defines the configuration for discovering and processing application routes (views and pages).",
      "related": {
        "methods": [],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "views": "type:TransformConfig<type:ResolvedRouteModule, type:RouteData, any>: Configuration for 'view' modules.",
          "pages": "type:TransformConfig<type:ResolvedRouteModule, type:RouteData, any>: Configuration for 'page' modules.",
          "generator": "type:GeneratorDefinition (optional): Custom generator definition for routes virtual module."
        }
      }
    },
    "ModuleConfig": {
      "id": "type:ModuleConfig",
      "definition": "interface ModuleConfig extends TransformConfig<unknown, unknown, unknown> {\n  readonly generator?: GeneratorDefinition;\n}",
      "purpose": "Extends `TransformConfig` to add an optional custom generator for a module group.",
      "related": {
        "methods": [],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "generator": "type:GeneratorDefinition (optional): Custom generator definition for this module group."
        }
      }
    },
    "ModulesConfig": {
      "id": "type:ModulesConfig",
      "definition": "interface ModulesConfig {\n  readonly [key: string]: ModuleConfig;\n}",
      "purpose": "A map of named module groups, each configured with a `ModuleConfig`.",
      "related": {
        "methods": [],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "[key: string]": "type:ModuleConfig: Each key represents a named module group."
        }
      }
    },
    "SitemapConfig": {
      "id": "type:SitemapConfig",
      "definition": "interface SitemapConfig {\n  readonly output: string;\n  readonly baseUrl: string;\n  readonly exclude?: ReadonlyArray<string>;\n}",
      "purpose": "Configuration for generating the `sitemap.xml` file.",
      "related": {
        "methods": ["method:generateSitemap"],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "output": "string: The output filename (e.g., 'sitemap.xml').",
          "baseUrl": "string: The base URL of the website.",
          "exclude": "ReadonlyArray<string> (optional): Glob patterns or regex strings to exclude routes."
        }
      }
    },
    "ExportOptions": {
      "id": "type:ExportOptions",
      "definition": "interface ExportOptions {\n  readonly types?: string;\n  readonly routeLimit?: number;\n}",
      "purpose": "Options for generating supplementary output files, like TypeScript types.",
      "related": {
        "methods": ["method:generateTypes"],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "types": "string (optional): File path for generated TypeScript declaration file (e.g., 'src/app/config/autogen.d.ts').",
          "routeLimit": "number (optional): Limits the number of routes included in `ApplicationRoute` type (default: 1000)."
        }
      }
    },
    "WatchOptions": {
      "id": "type:WatchOptions",
      "definition": "interface WatchOptions {\n  debounceTime?: number;\n  stabilityThreshold?: number;\n}",
      "purpose": "Configuration for the internal file watcher (`chokidar`) behavior.",
      "related": {
        "methods": ["method:createFileWatcher"],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "debounceTime": "number (optional): Delay in milliseconds before triggering an update (default: 1000).",
          "stabilityThreshold": "number (optional): Time in milliseconds to wait for write finish (default: 300)."
        }
      }
    },
    "ManifestConfig": {
      "id": "type:ManifestConfig",
      "definition": "interface ManifestConfig {\n  readonly name: string;\n  readonly shortName?: string;\n  readonly description?: string;\n  readonly theme_color?: string;\n  readonly background_color?: string;\n  readonly display?: \"fullscreen\" | \"standalone\" | \"minimal-ui\" | \"browser\";\n  readonly orientation?: \"any\" | \"natural\" | \"landscape\" | \"portrait\";\n  readonly scope?: string;\n  readonly start_url?: string;\n  readonly icons?: Array<{\n    src: string;\n    sizes: string;\n    type?: string;\n    purpose?: \"any\" | \"maskable\" | \"monochrome\";\n  }>;\n  readonly screenshots?: Array<{\n    src: string;\n    sizes: string;\n    type?: string;\n    platform?: \"wide\" | \"narrow\" | \"android\" | \"ios\" | \"windows\";\n  }>;\n  readonly related_applications?: Array<{\n    platform: string;\n    url: string;\n    id?: string;\n  }>;\n  readonly prefer_related_applications?: boolean;\n  readonly categories?: Array<string>;\n  readonly dir?: \"auto\" | \"ltr\" | \"rtl\";\n  readonly lang?: string;\n  readonly iarc_rating_id?: string;\n  readonly output?: string;\n}",
      "purpose": "Configuration for generating the PWA `manifest.webmanifest` file.",
      "related": {
        "methods": ["method:generateManifest"],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "name": "string: Full name of the application.",
          "shortName": "string (optional): Short name.",
          "description": "string (optional): Application description.",
          "theme_color": "string (optional): Default theme color.",
          "background_color": "string (optional): Background color.",
          "display": "\"fullscreen\" | \"standalone\" | \"minimal-ui\" | \"browser\" (optional): Preferred display mode (default: 'standalone').",
          "orientation": "\"any\" | \"natural\" | \"landscape\" | \"portrait\" (optional): Preferred orientation.",
          "scope": "string (optional): Navigation scope (default: '/').",
          "start_url": "string (optional): URL that loads when the user launches the app (default: '/').",
          "icons": "Array<object> (optional): Array of icon objects with `src`, `sizes`, `type`, `purpose`.",
          "screenshots": "Array<object> (optional): Array of screenshot objects with `src`, `sizes`, `type`, `platform`.",
          "related_applications": "Array<object> (optional): Array of related native applications with `platform`, `url`, `id`.",
          "prefer_related_applications": "boolean (optional): Hint for user agent.",
          "categories": "Array<string> (optional): Categories the app belongs to.",
          "dir": "\"auto\" | \"ltr\" | \"rtl\" (optional): Text direction.",
          "lang": "string (optional): Primary language.",
          "iarc_rating_id": "string (optional): IARC rating ID.",
          "output": "string (optional): Output filename (default: 'manifest.webmanifest')."
        }
      }
    },
    "PluginOptions": {
      "id": "type:PluginOptions",
      "definition": "interface PluginOptions {\n  readonly rootDir?: string;\n  readonly export?: ExportOptions;\n  readonly watch?: WatchOptions;\n  readonly sitemap?: SitemapConfig;\n  readonly manifest?: ManifestConfig;\n  readonly routes: RoutesConfig;\n  readonly modules: ModulesConfig;\n  readonly logLevel?: LogLevel;\n  readonly extract?: ExtractFunction;\n  readonly chunkSize?: number;\n}",
      "purpose": "The main configuration interface for the `@asaidimu/vite-autoload` Vite plugin, controlling all its features.",
      "related": {
        "methods": ["method:createAutoloadPlugin"],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "rootDir": "string (optional): The base directory for resolving relative paths (default: process.cwd()).",
          "export": "type:ExportOptions (optional): Options for generating supplementary output files.",
          "watch": "type:WatchOptions (optional): Configuration for the file watcher.",
          "sitemap": "type:SitemapConfig (optional): Configuration for sitemap generation.",
          "manifest": "type:ManifestConfig (optional): Configuration for PWA manifest generation.",
          "routes": "type:RoutesConfig: Configuration for application routes.",
          "modules": "type:ModulesConfig: Configuration for general application modules.",
          "logLevel": "type:LogLevel (optional): Verbosity of console output (default: 'info').",
          "extract": "type:ExtractFunction (optional): Function for metadata extraction logic.",
          "chunkSize": "number (optional): Number of routes/modules processed in a single batch (default: 100)."
        }
      }
    },
    "BuildContext": {
      "id": "type:BuildContext",
      "definition": "interface BuildContext {\n  readonly production: boolean;\n  readonly environment?: Environment;\n  readonly name?: string;\n  readonly split?: boolean;\n}",
      "purpose": "Context object provided during the build or data generation process, indicating environment and output preferences.",
      "related": {
        "methods": [],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "production": "boolean: True if in production build mode.",
          "environment": "type:Environment (optional): The build environment.",
          "name": "string (optional): Specific module name to generate code for (if splitting).",
          "split": "boolean (optional): Whether to split code generation into multiple files."
        }
      }
    },
    "VirtualModule": {
      "id": "type:VirtualModule",
      "definition": "type VirtualModule = `virtual:${string}`;",
      "purpose": "A string literal type representing a virtual module ID prefixed with `virtual:`.",
      "related": {
        "methods": [],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {}
      }
    },
    "FileExportMap": {
      "id": "type:FileExportMap",
      "definition": "interface FileExportMap {\n  readonly virtualModule: VirtualModule;\n  readonly exportKey: string;\n  readonly index: number;\n}",
      "purpose": "Internal mapping for tracking which file contributes to which part of a virtual module.",
      "related": {
        "methods": [],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "virtualModule": "type:VirtualModule: The ID of the virtual module.",
          "exportKey": "string: The key under which the file's data is exported.",
          "index": "number: The index of the file within its chunk."
        }
      }
    },
    "RouteGeneratorResult": {
      "id": "type:RouteGeneratorResult",
      "definition": "interface RouteGeneratorResult {\n  readonly views?: ReadonlyArray<RouteData>;\n  readonly pages?: ReadonlyArray<RouteData>;\n}",
      "purpose": "The structure of the data generated by the default routes generator, containing arrays of `RouteData` for views and pages.",
      "related": {
        "methods": [
          "method:createRouteGenerator",
          "method:defaultRoutesGenerator"
        ],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "views": "ReadonlyArray<type:RouteData> (optional): Array of transformed view data.",
          "pages": "ReadonlyArray<type:RouteData> (optional): Array of transformed page data."
        }
      }
    },
    "ResolvedFile": {
      "id": "type:ResolvedFile",
      "definition": "interface ResolvedFile {\n  uri: string;\n  path: string;\n  file: string;\n}",
      "purpose": "Represents a file discovered by the plugin, including its absolute URI for importing, relative path, and absolute filesystem path.",
      "related": {
        "methods": ["method:resolve"],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {
          "uri": "string: The full import URI for the file.",
          "path": "string: The relative path within its configured directory.",
          "file": "string: The absolute path on the filesystem."
        }
      }
    }
  },
  "methods": {
    "createAutoloadPlugin": {
      "id": "method:createAutoloadPlugin",
      "useCase": "Primary entry point to integrate `@asaidimu/vite-autoload` into a Vite project; configure automatic module discovery, code generation, sitemap, manifest, and HMR.",
      "signature": "(options: PluginOptions) => Plugin",
      "parameters": "options: type:PluginOptions - Comprehensive configuration object for the plugin.",
      "prerequisites": "Vite (v6.0.0+) must be installed and configured. Node.js (LTS, v18+) environment. Required peer and development dependencies (like `zod`, `@babel/parser`, `chokidar`, `es-module-lexer`) must be installed.",
      "sideEffects": "Registers various Vite hooks (`configResolved`, `configureServer`, `buildStart`, `resolveId`, `load`, `transformIndexHtml`, `transform`, `handleHotUpdate`, `closeBundle`). Starts an internal file watcher during development. Emits `sitemap.xml`, `manifest.webmanifest`, and TypeScript `.d.ts` files during production build.",
      "returnValue": "A Vite Plugin object, which should be added to the `plugins` array in `vite.config.ts`.",
      "exceptions": [
        "Error: If plugin configuration is invalid or essential file paths are inaccessible.",
        "Error: If underlying dependencies (e.g., `chokidar`) encounter file system errors."
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "types": ["type:PluginOptions"],
        "patterns": ["pattern:VitePluginIntegration"],
        "errors": []
      }
    },
    "generateMd5Hash": {
      "id": "method:generateMd5Hash",
      "useCase": "To generate an MD5 hash of a given string input, typically used internally by the plugin for creating unique identifiers or production URIs.",
      "signature": "(input: string) => string",
      "parameters": "input: string - The string to be hashed.",
      "prerequisites": "Node.js `crypto` module available (standard in Node.js environments).",
      "sideEffects": "None directly observable; performs a pure cryptographic hash computation.",
      "returnValue": "string - The MD5 hash of the input string as a hexadecimal string.",
      "exceptions": [],
      "availability": "sync",
      "status": "active",
      "related": {
        "types": [],
        "patterns": [],
        "errors": []
      }
    },
    "debounce": {
      "id": "method:debounce",
      "useCase": "To create a debounced version of a function, ensuring it is only called after a specified `wait` time has passed since its last invocation. Used internally by the file watcher to prevent excessive updates on rapid file changes.",
      "signature": "<T extends (...args: any[]) => void>(func: T, wait: number) => (...args: Parameters<T>) => void",
      "parameters": "func: T - The function to debounce. wait: number - The number of milliseconds to wait before invoking `func`.",
      "prerequisites": "None.",
      "sideEffects": "Introduces a delay in function execution. Repeated calls reset the timer.",
      "returnValue": "A new function that, when called, will execute `func` only after `wait` milliseconds have passed without any further calls to the new function.",
      "exceptions": [],
      "availability": "sync",
      "status": "active",
      "related": {
        "types": [],
        "patterns": [],
        "errors": []
      }
    },
    "resolve": {
      "id": "method:resolve",
      "useCase": "To resolve file paths based on a `FileMatchConfig` using glob patterns, returning an array of `ResolvedFile` objects. Used by module generators to find relevant source files.",
      "signature": "(config: FileMatchConfig) => Array<ResolvedFile>",
      "parameters": "config: type:FileMatchConfig - Configuration specifying directory, match patterns, and ignore patterns.",
      "prerequisites": "`fast-glob` package available (internal dependency).",
      "sideEffects": "Reads the filesystem to find matching files.",
      "returnValue": "Array<type:ResolvedFile> - An array of objects, each representing a matched file with its relative `path`, `uri`, and absolute `file` system path.",
      "exceptions": [
        "Error: If the `directory` specified in `FileMatchConfig` does not exist or is inaccessible."
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "types": ["type:FileMatchConfig", "type:ResolvedFile"],
        "patterns": [],
        "errors": []
      }
    },
    "generateManifest": {
      "id": "method:generateManifest",
      "useCase": "To generate a PWA `manifest.webmanifest` file based on provided configuration and write it to the specified output directory during the build process.",
      "signature": "(config: ManifestConfig, outDir: string) => string",
      "parameters": "config: type:ManifestConfig - Configuration for the PWA manifest. outDir: string - The output directory where the manifest file should be written.",
      "prerequisites": "Filesystem write access to `outDir`.",
      "sideEffects": "Creates or overwrites a `manifest.webmanifest` file in the specified `outDir`.",
      "returnValue": "string - The absolute path to the generated manifest file.",
      "exceptions": [
        "Error: If `outDir` is invalid or there are insufficient permissions to write the file."
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "types": ["type:ManifestConfig"],
        "patterns": [],
        "errors": []
      }
    },
    "generateTypes": {
      "id": "method:generateTypes",
      "useCase": "To generate TypeScript declaration (`.d.ts`) files containing union types (e.g., `ApplicationRoute` for route strings) based on collected values. This enhances type safety when consuming generated virtual modules.",
      "signature": "(outputPath: string, types: Record<string, string[]>) => Promise<void>",
      "parameters": "outputPath: string - The absolute path where the `.d.ts` file should be created. types: Record<string, string[]> - An object mapping type names to arrays of string values that will form the union type (e.g., `{ ApplicationRoute: ['/', '/about', '/contact'] }`).",
      "prerequisites": "Filesystem write access to `outputPath`.",
      "sideEffects": "Creates directories recursively and writes a TypeScript declaration file at `outputPath`.",
      "returnValue": "Promise<void> - A promise that resolves when the file has been written.",
      "exceptions": [
        "Error: If `outputPath` is invalid or there are insufficient permissions to write the file."
      ],
      "availability": "async",
      "status": "active",
      "related": {
        "types": ["type:ExportOptions"],
        "patterns": [],
        "errors": []
      }
    },
    "createModuleGenerator": {
      "id": "method:createModuleGenerator",
      "useCase": "To create a flexible module generator instance responsible for discovering files, processing them via `transform` and `aggregate` functions, and generating the corresponding virtual module code. This is an internal component that the main `createAutoloadPlugin` leverages.",
      "signature": "(options: { name: string; config: Record<string, TransformConfig<any, any, any>> }) => { name: string; config: Record<string, TransformConfig<any, any, any>>; modules: (params: { production: boolean }) => Array<ResolvedRouteModule & { module: string }>; data: (params: { production: boolean }) => Record<string, Array<RouteData>>; code: (params: { production: boolean; name?: string; split?: boolean }) => string | Record<string, string>; match: (file: string) => boolean; add: (file: string) => void; remove: (file: string) => void; find: (searchName: string) => boolean; }",
      "parameters": "options: object - name: string - The name of this generator instance (e.g., 'routes', 'components'). config: Record<string, TransformConfig<any, any, any>> - A mapping of module keys to their `TransformConfig` objects.",
      "prerequisites": "Valid `TransformConfig` objects must be provided for each module key.",
      "sideEffects": "Initializes an internal cache of resolved files. `data` and `code` methods perform transformations and generate code based on this cache.",
      "returnValue": "An object providing methods to query module data (`modules`, `data`), generate code (`code`), and manage the internal file cache (`match`, `add`, `remove`, `find`).",
      "exceptions": [
        "Error: If no metadata is found in a file when the extractor expects it."
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "types": [
          "type:TransformConfig",
          "type:ResolvedRouteModule",
          "type:RouteData"
        ],
        "patterns": [],
        "errors": []
      }
    },
    "generateSitemap": {
      "id": "method:generateSitemap",
      "useCase": "To generate an XML sitemap (`sitemap.xml`) string based on a list of route entries, a base URL, and optional exclusions. Used during the production build.",
      "signature": "(routes: ReadonlyArray<SitemapEntry>, baseUrl: string, exclude: ReadonlyArray<string> = []) => string",
      "parameters": "routes: ReadonlyArray<SitemapEntry> - An array of objects, each containing a `route` string and optional `metadata` (e.g., `changefreq`, `priority`). baseUrl: string - The base URL of your website (e.g., 'https://example.com'). exclude: ReadonlyArray<string> - An optional array of glob patterns to exclude routes from the sitemap (default: `[]`).",
      "prerequisites": "None.",
      "sideEffects": "None (returns a string, does not write to disk).",
      "returnValue": "string - The complete XML content for the sitemap.",
      "exceptions": [],
      "availability": "sync",
      "status": "active",
      "related": {
        "types": ["type:SitemapConfig"],
        "patterns": [],
        "errors": []
      }
    },
    "createRouteGenerator": {
      "id": "method:createRouteGenerator",
      "useCase": "Creates an API for managing and generating route data based on plugin options. This is a legacy/alternative route generation logic compared to the more flexible `createModuleGenerator` used by the new generator system.",
      "signature": "(options: PluginOptions, logger: Logger) => { readonly getData: (context: BuildContext) => RouteGeneratorResult; readonly getCode: (context: BuildContext) => string | Record<string, string>; readonly hasFile: (file: string) => boolean; readonly addFile: (file: string) => void; readonly removeFile: (file: string) => void; }",
      "parameters": "options: type:PluginOptions - Plugin configuration options. logger: type:Logger - A logger instance for internal messages.",
      "prerequisites": "Valid `PluginOptions` are required, particularly `options.routes`.",
      "sideEffects": "Initializes an internal cache of resolved route modules. `addFile` and `removeFile` modify this cache. `getData` and `getCode` produce data/code based on the cache.",
      "returnValue": "An object with methods to retrieve data (`getData`), generate code (`getCode`), and manage tracked files (`hasFile`, `addFile`, `removeFile`).",
      "exceptions": [
        "Error: 'Failed to initialize routes' if there's an issue with file resolution or configuration."
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "types": [
          "type:PluginOptions",
          "type:Logger",
          "type:BuildContext",
          "type:RouteGeneratorResult"
        ],
        "patterns": [],
        "errors": []
      }
    },
    "createMetadataExtractor": {
      "id": "method:createMetadataExtractor",
      "useCase": "To create a metadata extractor instance that can statically analyze TypeScript files, extract exported object literal values, validate them against a Zod schema, and transform them into a desired runtime format (e.g., dynamic imports).",
      "signature": "(schema: z.ZodType, options: { exportName?: string | 'default' } = { exportName: 'metadata' }) => { extract: (filePath: string) => any; }",
      "parameters": "schema: z.ZodType - The Zod schema to validate extracted metadata against. options: object (optional) - exportName: string | 'default' - The name of the exported constant (or 'default' for default exports) to extract metadata from (default: 'metadata').",
      "prerequisites": "TypeScript and Zod must be installed. The target file must be a valid TypeScript/JavaScript file.",
      "sideEffects": "Reads the specified `filePath`. If an error occurs during parsing or validation, it logs a warning.",
      "returnValue": "An object with an `extract` method. The `extract` method returns the validated and potentially transformed metadata object, or `null` if extraction fails or no metadata is found.",
      "exceptions": [
        "Error: 'Invalid import string format' if a dynamic import string is malformed.",
        "Error: 'No metadata found' if the specified `exportName` is not found in the file.",
        "Error: 'Invalid metadata' if the extracted data does not conform to the provided Zod `schema` (provides detailed Zod error messages)."
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "types": ["type:ExtractOptions", "type:ExtractFunction"],
        "patterns": ["pattern:MetadataExtraction"],
        "errors": ["error:ZodValidationError"]
      }
    },
    "extract": {
      "id": "method:extract",
      "useCase": "A convenient wrapper function to directly extract metadata from a given file path using a specified Zod schema and exported name. It internally uses `createMetadataExtractor`.",
      "signature": "<T>({ filePath, schema, name }: { filePath: string; schema: z.ZodType; name: string }) => T",
      "parameters": "filePath: string - The absolute path to the file. schema: z.ZodType - The Zod schema for validation. name: string - The name of the exported constant or 'default' to extract.",
      "prerequisites": "TypeScript and Zod installed. `createMetadataExtractor` and its dependencies are available.",
      "sideEffects": "Reads the specified `filePath` and performs static analysis.",
      "returnValue": "T - The extracted and validated metadata object, typed according to the provided `schema`.",
      "exceptions": [
        "Error: Propagates errors from `createMetadataExtractor`, such as 'Invalid metadata' or 'No metadata found'."
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "types": ["type:ExtractOptions", "type:ExtractFunction"],
        "patterns": ["pattern:MetadataExtraction"],
        "errors": ["error:ZodValidationError"]
      }
    },
    "isJavaScriptLikeModule": {
      "id": "method:isJavaScriptLikeModule",
      "useCase": "To check if a given module ID (file path) corresponds to a JavaScript-like file type (e.g., .js, .jsx, .ts, .tsx). Used internally by the plugin to filter which files to process for HMR.",
      "signature": "(id: string) => boolean",
      "parameters": "id: string - The module ID, typically a file path.",
      "prerequisites": "None.",
      "sideEffects": "None.",
      "returnValue": "boolean - `true` if the ID ends with a JavaScript/TypeScript file extension, `false` otherwise.",
      "exceptions": [],
      "availability": "sync",
      "status": "active",
      "related": {
        "types": [],
        "patterns": [],
        "errors": []
      }
    },
    "defaultRoutesGenerator": {
      "id": "method:defaultRoutesGenerator",
      "useCase": "A predefined `GeneratorDefinition` for handling `routes` (views and pages). It defines standard logic for extracting route data, generating code with chunking, and extracting types/sitemap entries.",
      "signature": "const defaultRoutesGenerator: GeneratorDefinition",
      "parameters": "None (this is an object, not a function that takes direct parameters for its definition).",
      "prerequisites": "None.",
      "sideEffects": "As a definition, it has no direct side effects until used by `createAutoloadPlugin`.",
      "returnValue": "type:GeneratorDefinition - A pre-configured generator definition for routes.",
      "exceptions": [],
      "availability": "sync",
      "status": "active",
      "related": {
        "types": ["type:GeneratorDefinition", "type:RoutesConfig"],
        "patterns": [],
        "errors": []
      }
    },
    "createDefaultModuleGenerator": {
      "id": "method:createDefaultModuleGenerator",
      "useCase": "A factory function to create a default `GeneratorDefinition` for a given module key. It provides standard logic for data extraction, code generation with chunking, and module resolution for generic module groups.",
      "signature": "(key: string) => GeneratorDefinition",
      "parameters": "key: string - The name of the module group (e.g., 'components', 'hooks'). This key will also be used to derive the `virtualId` (e.g., `virtual:components`).",
      "prerequisites": "None.",
      "sideEffects": "None (returns a definition object).",
      "returnValue": "type:GeneratorDefinition - A pre-configured generator definition for a generic module group.",
      "exceptions": [],
      "availability": "sync",
      "status": "active",
      "related": {
        "types": ["type:GeneratorDefinition", "type:ModulesConfig"],
        "patterns": [],
        "errors": []
      }
    },
    "createCustomGenerator": {
      "id": "method:createCustomGenerator",
      "useCase": "To create a customized `GeneratorDefinition` by extending a base generator (like `defaultRoutesGenerator`) with specific overrides for its `dataExtractor`, `codeGenerator`, `typesExtractor`, or `sitemapExtractor`.",
      "signature": "(base: GeneratorDefinition, overrides: Partial<GeneratorDefinition>) => GeneratorDefinition",
      "parameters": "base: type:GeneratorDefinition - The base generator definition to extend. overrides: Partial<GeneratorDefinition> - An object containing properties to override in the base generator.",
      "prerequisites": "A valid base `GeneratorDefinition` is required.",
      "sideEffects": "None (returns a new definition object).",
      "returnValue": "type:GeneratorDefinition - A new generator definition with merged properties from the base and overrides.",
      "exceptions": [],
      "availability": "sync",
      "status": "active",
      "related": {
        "types": ["type:GeneratorDefinition"],
        "patterns": [],
        "errors": []
      }
    },
    "generators": {
      "id": "method:generators",
      "useCase": "An exported object containing factory functions and default generator definitions for user convenience when configuring custom generator logic.",
      "signature": "const generators: {\n  routes: GeneratorDefinition;\n  createModule: (key: string) => GeneratorDefinition;\n  createCustom: (base: GeneratorDefinition, overrides: Partial<GeneratorDefinition>) => GeneratorDefinition;\n}",
      "parameters": "None (this is an object, its properties are functions).",
      "prerequisites": "None.",
      "sideEffects": "None.",
      "returnValue": "An object providing direct access to `defaultRoutesGenerator`, `createDefaultModuleGenerator` (aliased as `createModule`), and `createCustomGenerator`.",
      "exceptions": [],
      "availability": "sync",
      "status": "active",
      "related": {
        "types": ["type:GeneratorDefinition"],
        "patterns": [],
        "errors": []
      }
    },
    "createLogger": {
      "id": "method:createLogger",
      "useCase": "To create a logger instance for consistent console output within the plugin, respecting a specified `LogLevel`.",
      "signature": "(level: LogLevel = 'info') => Logger",
      "parameters": "level: type:LogLevel (optional) - The minimum log level to display (default: 'info').",
      "prerequisites": "None.",
      "sideEffects": "Outputs messages to the console based on the configured `logLevel`.",
      "returnValue": "An object implementing the `Logger` interface with `debug`, `info`, `warn`, and `error` methods.",
      "exceptions": [],
      "availability": "sync",
      "status": "active",
      "related": {
        "types": ["type:LogLevel"],
        "patterns": [],
        "errors": []
      }
    },
    "createFileWatcher": {
      "id": "method:createFileWatcher",
      "useCase": "To create and manage a file system watcher (`chokidar`) that monitors specified directories for changes, additions, or deletions, and triggers a callback. Used internally by the plugin for HMR.",
      "signature": "(options: PluginOptions, logger: Logger, onChange: (changedFiles: string[]) => Promise<void>) => { readonly start: () => void; readonly stop: () => void; }",
      "parameters": "options: type:PluginOptions - Plugin configuration, specifically for `watch` options and directories to watch. logger: type:Logger - A logger instance for watcher messages. onChange: (changedFiles: string[]) => Promise<void> - An asynchronous callback function invoked when files change, debounced according to `watch.debounceTime`.",
      "prerequisites": "`chokidar` package must be installed. Filesystem access to watched directories.",
      "sideEffects": "Initializes and manages a filesystem watcher. Triggers `onChange` callback on file system events. Logs watcher status and errors.",
      "returnValue": "An object with `start()` and `stop()` methods to control the watcher lifecycle.",
      "exceptions": [
        "Error: 'Failed to start file watcher' if chokidar encounters an unrecoverable error during initialization.",
        "Error: Propagates errors from `chokidar` (e.g., permission errors, invalid paths)."
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "types": ["type:PluginOptions", "type:Logger", "type:WatchOptions"],
        "patterns": [],
        "errors": []
      }
    }
  },
  "decisionTrees": {
    "HMRTroubleshooting": {
      "id": "decisionTree:HMRTroubleshooting",
      "question": "HMR (Hot Module Replacement) is not working as expected when modifying source files tracked by the plugin.",
      "logic": "IF `logLevel` is not `debug` THEN set `logLevel: 'debug'` AND re-run dev server. ELSE IF `[vite-autoload]` logs show file changes but no HMR update THEN check if the virtual module is being imported. ELSE IF virtual module is imported THEN check Vite's module graph (e.g., `server.moduleGraph.getModuleById(virtualId)`) and its `importers`. ELSE IF HMR is still not working after checking imports THEN adjust `watch.debounceTime` or `watch.stabilityThreshold` to ensure changes are fully written and processed. ELSE IF still no HMR THEN investigate potential conflicts with other Vite plugins or custom HMR logic.",
      "validationMethod": "Observe console logs for `[vite-autoload]` messages, check browser's dev tools for HMR updates, manually inspect Vite's module graph (if accessible).",
      "related": {
        "methods": ["method:createAutoloadPlugin", "method:createFileWatcher"],
        "patterns": [],
        "errors": []
      }
    },
    "ModuleConfiguration": {
      "id": "decisionTree:ModuleConfiguration",
      "question": "How to configure a new group of files (e.g., components, hooks) to be automatically loaded and exposed as a virtual module?",
      "logic": "IF files are general application modules (not routes) THEN add a new key-value pair under `PluginOptions.modules`. ELSE IF files are top-level views or pages THEN configure them under `PluginOptions.routes.views` or `PluginOptions.routes.pages`. THEN define `input.directory` and `input.match` patterns. THEN implement a `transform` function to convert `ResolvedFile` into desired `RouteData` or custom structure. OPTIONALLY, IF aggregation is needed (e.g., array to map) THEN implement `aggregate` function. OPTIONALLY, IF type generation is desired THEN configure `output.types`.",
      "validationMethod": "Import the new virtual module (e.g., `import { myModule } from 'virtual:myModule';`) in your application and log its content to verify the data structure. Check for generated `.d.ts` types.",
      "related": {
        "methods": [
          "method:createAutoloadPlugin",
          "method:createDefaultModuleGenerator"
        ],
        "patterns": ["pattern:ModuleConfigurationExample"],
        "errors": []
      }
    },
    "MetadataExtraction": {
      "id": "decisionTree:MetadataExtraction",
      "question": "How to extract structured metadata from source files and include it in generated virtual modules?",
      "logic": "IF metadata is not yet defined in source file THEN `export const metadata = { /* ... */ };` or `export default { /* ... */ };` in target files. THEN define a `zod` schema matching the metadata structure. THEN pass the `filePath`, `schema`, and exported `name` ('metadata' or 'default') to the `extract` function within the `transform` method of your `TransformConfig`. ELSE IF `extract` fails THEN check `ZodValidationError` for schema mismatch details.",
      "validationMethod": "Inspect the `metadata` property of the transformed objects in your virtual module (`console.log(views[0].metadata)`). Verify against your Zod schema and source file content.",
      "related": {
        "methods": ["method:extract", "method:createMetadataExtractor"],
        "patterns": ["pattern:MetadataExtraction"],
        "errors": ["error:ZodValidationError"]
      }
    }
  },
  "patterns": {
    "VitePluginIntegration": {
      "id": "pattern:VitePluginIntegration",
      "description": "Standard way to integrate the autoload plugin into your Vite project by adding it to the `plugins` array in `vite.config.ts`.",
      "example": {
        "code": "import { defineConfig } from \"vite\";\nimport { createAutoloadPlugin, extract } from \"@asaidimu/vite-autoload\";\nimport createAutoloadConfig from \"./autoload.config\";\n\nexport default defineConfig({\n  plugins: [\n    createAutoloadPlugin(createAutoloadConfig({ extract }))\n  ],\n});",
        "validation": "Vite dev server starts without plugin errors; `[vite-autoload]` logs appear in console."
      },
      "related": {
        "methods": ["method:createAutoloadPlugin"],
        "errors": []
      }
    },
    "ModuleConfigurationExample": {
      "id": "pattern:ModuleConfigurationExample",
      "description": "Example of configuring a 'components' module group, demonstrating file matching, transformation, aggregation, and type generation.",
      "example": {
        "code": "// autoload.config.ts\nmodules: {\n  components: {\n    input: {\n      directory: \"src/components\",\n      match: [\"*.tsx\", \"*/index.tsx\"],\n      ignore: [\"**/__tests__/**\"],\n      prefix: \"/components/\"\n    },\n    output: {\n      name: \"components\",\n      template: \"export const components = {{ data }};\\nexport default components;\",\n      types: { name: \"ComponentKeys\", key: \"name\" }\n    },\n    transform: (item) => ({\n      name: item.path.split('/').pop()?.replace(/\\.tsx?$/, ''),\n      route: item.path,\n      path: item.uri\n    }),\n    aggregate: (items) => items.reduce((acc, item) => ({ ...acc, [item.name!]: item.path }), {})\n  }\n}",
        "validation": "`import { components } from 'virtual:components';` yields an object like `{ Button: '/components/Button.js', Input: '/components/Input.js' }`. `src/app/config/autogen.d.ts` contains `export type ComponentKeys = 'Button' | 'Input';`."
      },
      "related": {
        "methods": ["method:createDefaultModuleGenerator"],
        "errors": []
      }
    },
    "MetadataExtraction": {
      "id": "pattern:MetadataExtraction",
      "description": "Demonstrates how to embed and extract structured metadata from your source files using Zod for validation.",
      "example": {
        "code": "// src/interface/pages/home.tsx\nexport const metadata = {\n  title: \"Home Page\",\n  authRequired: false,\n};\n\n// In autoload.config.ts transform function\nimport { z } from \"zod\";\n// ...\ntransform: (page) => {\n  // ...\n  return {\n    route: page.route,\n    path: page.uri,\n    metadata: extract({\n      filePath: page.file,\n      schema: z.object({ title: z.string(), authRequired: z.boolean().optional() }),\n      name: \"metadata\",\n    }),\n  };\n},",
        "validation": "The `metadata` property of the corresponding entry in the virtual module (e.g., `pages[0].metadata`) contains `{ title: 'Home Page', authRequired: false }`."
      },
      "related": {
        "methods": ["method:extract", "method:createMetadataExtractor"],
        "errors": ["error:ZodValidationError"]
      }
    }
  },
  "errors": {
    "ZodValidationError": {
      "id": "error:ZodValidationError",
      "type": "z.ZodError",
      "symptoms": "Build failure or `metadata` property in transformed objects appears `null` or `undefined`. Console output will show detailed validation messages from Zod (`.path` and `.message`).",
      "properties": "The `ZodError` object includes an `errors` array, where each element provides `path` (array of strings/numbers indicating location of error in object) and `message` (string description of validation failure).",
      "scenarios": [
        {
          "trigger": "A required property in the Zod schema is missing from the exported metadata object in the source file.",
          "example": "// Source file: export const metadata = { };\n// Schema: z.object({ title: z.string() })",
          "reason": "Missing key 'title' at path 'title'"
        },
        {
          "trigger": "A property in the exported metadata object has a type that doesn't match the Zod schema.",
          "example": "// Source file: export const metadata = { title: 123 };\n// Schema: z.object({ title: z.string() })",
          "reason": "Expected string, received number at path 'title'"
        }
      ],
      "diagnosis": "Check the detailed Zod error messages in the console (set `logLevel: 'debug'`). Compare the `path` and `message` to the `metadata` object in your source file and its corresponding `zod` schema. Ensure all fields are present, have correct types, and account for optional fields with `.optional()` or default values with `.default()`.",
      "resolution": "Update the exported metadata object in your source file to strictly conform to the `zod` schema, or adjust your `zod` schema to accurately reflect the data structure present in your source files.",
      "prevention": "Thoroughly test your `extract` function with various valid and invalid metadata examples. Use `.optional()` for non-mandatory fields. Ensure your Zod schema is always up-to-date with your metadata definitions.",
      "handlingPatterns": "Catch the `ZodError` in your `transform` function to provide a fallback or custom error handling. This prevents the entire build from failing due to a single malformed metadata object.\n\n```typescript\nimport { z } from \"zod\";\nimport { extract } from \"@asaidimu/vite-autoload\";\n\nconst MyMetadataSchema = z.object({ title: z.string(), authRequired: z.boolean().optional() });\n\ntransform: (item) => {\n  let metadata = null;\n  try {\n    metadata = extract({ filePath: item.file, schema: MyMetadataSchema, name: \"metadata\" });\n  } catch (error) {\n    // Log a warning for human debugging, but allow build to continue\n    console.warn(`[Autoload Plugin] Failed to extract metadata for ${item.file}:`, error.message);\n    // Provide a default or partial metadata object to avoid breaking downstream logic\n    metadata = { title: \"Untitled\", authRequired: false }; \n  }\n  return { /* ... other item properties ... */, metadata };\n}\n```",
      "propagationBehavior": "If not caught by the `transform` function, `ZodError` exceptions during metadata extraction can cause the Vite build to fail. In development mode, they might be logged as warnings, resulting in `null` or `undefined` for the `metadata` property, which could lead to runtime errors in the consuming application if not gracefully handled."
    }
  }
}
